# &运算符的巧妙应用

## 语法：
`&`:and，按位与。以`$a & $b`为例，将$a和$b中都为1的位设为1。

**程序**

```
$a = 6;
$b = 3;

var_dump($a & $b);
```

**输出:**`int(2)`

**原理** 

+ `$a = 6`转化为2进制为`110`
+ `$b = 3`转化为2进制为`11`
+ `$a & $b`即是 `110` 与 `11`
+ 将$a和$b中都为1的位设为1,位数不够的补0.即`110` 与 `011`
+ 运算结果`010`,转化为十进制结果为2


## 应用：

### 需求：
> 这是一个设置消息提醒的功能，如果用户执行了操作1，希望系统给用户发送一个提醒，提醒方式可以是1也可以是2
或者两者同时提醒。也可以设置全部关闭消息提醒。可以参考以下表格：

| 提醒操作  | 提醒方式1 | 提醒方式2 | 
|---------|----------|---------|
|  操作1   | 开关按钮   | 开关按钮 |
|  操作2   | 开关按钮   | 开关按钮 |  
|  操作3   | 开关按钮   | 开关按钮 |  

### 实现
1、数据库设计remind：

| 操作1  | 操作2 | 操作3 | 
|---------|----------|---------|

2、在remind Model中设置执行操作的提醒方式类型：

```
cosnt REMIND_NO = 0;//关闭所有的提醒
cosnt REMIND_ONE = 1;//开启提醒方式1
cosnt REMIND_TWO = 2;//开启提醒方式2
```

+ 如果关闭操作n所有的提醒，那数据库中操作n对应的值应是：0；
+ 如果开启操作n的提醒方式1，那数据库中操作n对应的值应是：1；
+ 如果开启操作n的提醒方式2，那数据库中操作n对应的值应是：2；
+ 如果开启操作n的所有提醒方式，那数据库中操作n对应的值应是：1+2=3；
+ 如果有新的提醒方式值应为`4`或`8`，可以发现设置值的规律为2的n次方。

为什么这么设计？应为怕值有重复。我们先看下能设置的值有`0`,`1`,`2`,`4`,`8`.
我们将`0`,`1`,`2`,`4`,`8`中的值任意相加，不会等于里面任意一值。
如果能设置的值是`0`,`1`,`2`,`3`,`5`.那当值为5的时候，是提醒方式5，还是提醒方式2+提醒方式3呢？
所以按照2的n次方规律设置，就不会出现这种情况。

3、关于消息提醒设置，我们需要写两个方法，一个是读取当前用户的设置，另一个是设置消息提醒。
**重点来了，前方高能，请注意啦～**

我们以设置消息提醒为例：
```
$option = '';//提醒操作,由前端传来的值
$type = '';//提醒方式，由前端传来的值

$remind = Remind::model()->find(1);//根据条件，在数据库中找到的一条记录
// 如果是提醒方式一
if ($type == "remind_one") {
	if ($remind－>$option & Remind::REMIND_ONE) {
		// true 代表已开启REMIND_ONE提醒，此时应关闭REMIND_ONE提醒
		$remind－>$option -= Remind::REMIND_ONE;
	} else if (!($remind－>$option & Remind::REMIND_ONE)) {
		// false 代表已关闭REMIND_ONE提醒，此时应开启REMIND_ONE提醒
		$remind－>$option += Remind::REMIND_ONE;
	}
}
// 如果是提醒方式二
if ($type == "remind_two") {
	if ($remind－>$option & Remind::REMIND_TWO) {
		$remind－>$option -= Remind::REMIND_TWO;
	} else if (!($remind－>$option & Remind::REMIND_TWO)) {
		$remind－>$option += Remind::REMIND_TWO;
	}
}
```

我们来详细的解释下：

我们先假如数据库操作1的值默认为0：

+ 此时前端传来$type＝remind_one,即提醒方式1；
+ 接下来我们要判断提醒方式1在数据库中是开启的还是关闭的，采用与&运算；
+ 即`1&0`,运算结果`0`,`0`相当于false,即提醒方式1是关闭的；

假如数据库操作1的值为2：

+ 如果前端传来$type＝remind_one，即提醒方式1；
+ 判断开启还是关闭，通过`1&2`,即`01`&`10` 运算结果`00`,即`0`;
+ `0`相当于false,即提醒方式1是关闭的；

假如数据库操作1的值为3：

+ 如果前端传来$type＝remind_one，即提醒方式1；
+ 判断开启还是关闭，通过`1&3`,即`01`&`11` 运算结果`01`,即`1`;
+ `1`相当于true，只要值>0,都相当与true，即提醒方式1是开启的；

### 总结
采用&运算的好处：

+ 减少了数据库设计的复杂性，一张表即可搞定；不用一张表纪录操作，另一张表纪录提醒方式，然后再关联；
+ 减少前端的判断，前端只需将当前的操作和其对应的值传给后端即可。

## 扩展
>待补充


参考：
[PHP位运算 详解](http://www.php100.com/html/webkaifa/PHP/PHPyingyong/2013/0821/13762.html)